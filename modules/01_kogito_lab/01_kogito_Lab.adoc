:noaudio:
:scrollbar:
:data-uri:
:toc2:
:linkattrs:

= RHTE 2019: Cloud-Native and Serverless Processes and Decisions with jBPM, Drools and Quarkus

:numbered:

== Lab environment and setup

.Prerequisites
.. The `ssh` utility installed on your laptop.
.. Web browser installed on your laptop.
.. Broadband internet connectivity.

A lab environment is provided to you. The environment consists of:

* An Openshift cluster.
* A virtual machine with developer tools (git, JDK, Maven, GraalVM) installed.

To obtain access to your lab environment:

. In a browser window, navigate to the RHTE _GuidGrabber_ at https://www.opentlc.com/gg/gg.cgi?profile=???
+
image::images/guid_grabber_1.png[]
. Select the *Lab Code* : `S003 - Cloud-Native and Serverless Processes and Decisions with jBPM, Drools and Quarkus`
. Enter the *Activation Key* provided by your instructor.
. Enter your *E-Mail Address*.
. Click *Submit*
. The resulting page will display your lab's _GUID_ and other useful information about your lab environment.
+
image::images/guid_grabber_2.png[]
. Open a terminal window and log into the lab virtual machine:
+
----
$ export GUID=<your GUID obtained from the GuidGrabber>
$ ssh lab-user@workstation-$GUID.rhpds.opentlc.com
----
* When prompted, enter the password provided by the instructor.
. From the workstation, you can log into the OpenShift cluster using the `oc` utility:
+
----
$ oc login -u user1 https://master00.example.com -u user1
----
+
.Sample output
----
The server is using a certificate that does not match its hostname: x509: certificate is valid for kubernetes, kubernetes.default, kubernetes.default.sv
c, kubernetes.default.svc.cluster.local, master00.example.com, openshift, openshift.default, openshift.default.svc, openshift.default.svc.cluster.local,
 172.30.0.1, 192.168.0.10, not master00-b8ad.generic.opentlc.com
You can bypass the certificate check, but any data you send to the server could be intercepted by others.
Use insecure connections? (y/n): y

Username: user1
Password:
Login successful.
----
* Accept to use insecure connections.
* When prompted, enter the pasword provided by the instructor.
. To access the OpenShift cluster console from your laptop, open a browser window and navigate to the url https://master00-<GUID>.generic.opentlc.com - replace <GUID> with the lab GUID from the GuidGrabber tool.
* Your OpenShift cluster uses self-signed certificates, so expect a security warning in the browser. Create a security exception and proceed.
* Login with user `user1` and the password provided by the lab instructor.


== Use Case

During this workshop we will create and deploy a software system for a startup travel agency called Kogito Travel Agency.
The system will consist of a Kogito _Booking System Service_ implemented with a BPMN2 process definition and rules.

image:images/travels-process.png[]

The _Hotel Booking_ and _Flight Booking_ functionalities are implemented as _private_ subprocesses

image:images/book-hotel-process.png[]

image:images/book-flight-process.png[]

These processes call _Hotel Booking Service_ and _Flight Booking Service_, which are both implemented as CDI beans that have hard coded logic to return a booked flight or hotel.

org.acme.travels.service.HotelBookingService
org.acme.travels.service.FlightBookingService

Obviously this has been done for simplicity reasons. In a real application these functionalities would be implemented as microservices. However, the current implementation does show the power of Kogito processes definition integration with CDI.

== Cloning the repository
You are provided with a GitHub repository that contains 3 Kogito projects:

* 01-kogito-travel-agency: The base project which contains the _Booking System Service_. This project deploys as a single Quarkus application (JAR or Native Image) and does not support persistence.
* 02-kogito-travel-agency: The base project with persistence support. This project requires Infinispan / JBoss Data Grid.
* 03-kogito-travel-agency: Extension of project 3 with Kafka integration support to implement an Event Driven _Booking System Service_.

The GitHub repository can be found here: https://github.com/rhte2019-kogito/kogito-travel-agency-tutorial/


. Login to your workstation as explained in the previous paragraph.
. When logged in, clone the Kogito Lab repository:
+
----
$ git clone https://github.com/rhte2019-kogito/kogito-travel-agency-tutorial.git
----
+
. Navigate tot the _Kogito Travel Agency Tutorial_ folder.
+
----
$ cd kogito-travel-agency-tutorial
----
+
. This folder contains the 3 projects that we will use during this lab.
. Switch to the `rhte2019` branch of the repository.
+
----
$ git checkout rhte2019
----
+


== Lab 1: Kogito Development

https://kogito.kie.org/[_Kogito_] is the _Cloud-Native Business Automation platform for building Intelligent Applications_.
It's build on top of https://www.quarkus.io[Quarkus], a _Kubernetes Native Java stack tailored for GraalVM & OpenJDK HotSpot, crafted from the best of breed Java libraries and standards_.

One of the focusses of Quarkus, and thus of Kogito, is _Developer Experience_. Functionalities like _dev mode_ and _hot reload_ allows developers to make changes in their source code and configuration files, and immediately have these changes available in their test environment, without the need to explicitly compile and redeploy the application. This _hot reload_ functionality is only activated when the application is refreshed (for example when hitting the application with a RESTful request).

When you run `mvn compile quarkus:dev` {project-name}, the Kogito/Quarkus application will launch in development mode. When
it receives a HTTP request it will hold the request, and check to see if any application source
files (Java code, process definitions, rule definitions, etc.) have been changed. If they have it will transparently compile the changed files, redeploy
the application with the changed files, and then the HTTP request will continue to the redeployed
application. Project redeploys are much faster than a traditional app server, so for all but the largest
applications this should take well under a second. This greatly speeds up a developer's development cycle.

Kogito provides support for not only hot-reloading source code, but also business assets, like BPMN2 process definitions, DMN decision definitions, DRL rule files, Excel-based decision tables. This makes Kogito and its supported resources a first-class-citizen in the Quarkus eco-system.

In this part of the lab, we will experience the _hot-reload_ semantics of Kogito by altering the rules of our _Kogito Travel Agency_ application.

1. From the `/home/lab-user/kogito-travel-agency-tutorial` folder, navigate to the `01-kogito-travel-agency` folder.
+
----
$ cd 01-kogito-travel-agency
----
+
. Run the Maven command to start the Kogito application in _dev-mode_.
+
----
mvn clean package quarkus:dev
----
+
. If everything executed correctly, you will now see the applicatio running in _dev-mode_.
+
----
[INFO] --- quarkus-maven-plugin:0.20.0:dev (default-cli) @ kogito-travel-agency ---
Listening for transport dt_socket at address: 5005
2019-08-23 11:19:53,578 INFO  [io.qua.dep.QuarkusAugmentor] (main) Beginning quarkus augmentation
2019-08-23 11:20:00,485 INFO  [io.qua.dep.QuarkusAugmentor] (main) Quarkus augmentation completed in 6907ms
2019-08-23 11:20:00,878 INFO  [io.qua.swa.run.SwaggerUiServletExtension] (main) Swagger UI available at /swagger-ui
2019-08-23 11:20:01,515 INFO  [io.quarkus] (main) Quarkus 0.20.0 started in 8.297s. Listening on: http://[::]:8080
2019-08-23 11:20:01,542 INFO  [io.quarkus] (main) Installed features: [cdi, kogito, resteasy, resteasy-jsonb, smallrye-openapi, swagger-ui]
----
+

We can see that the applications has a number of features installed, including _kogito_ to provide intelligent business application support, _resteasy_ to provide RESTful support, and _swagger-ui_ to provide swagger support.

Let's first access the application via the provided user interface.

. On your laptop, open a browser (Chrome, Firefox) and navigate to your workstation at: http://workstation-$GUID.rhpds.opentlc.com:8080 (replace $GUID with the GUID provided to you)
. You will see the following application UI.
image:images/kogito-travel-agency-ui-home.png[]

First we want to explore the semantic of our service. As we can see in the process diagram, the first node that is executed is _Business Rules_ node.

image:images/travels-process.png[]

This node executes the rules that determine whether an booking requires a visa or not. The rules can be found in the `visa-rules.drl` file located in the package `org.acme.travels` in the `src/main/resources` folder of the project.
Let's take a quick look at the rules:

----
rule "Polish citizens require visa to US"
	ruleflow-group "visas"
	when
		$trip: Trip($trip.country == "US")
		$traveller : Traveller($traveller.nationality == "Polish")
	then
		$trip.setVisaRequired( true );
end

rule "Polish citizens do not require visa to UK"
	ruleflow-group "visas"
	when
		$trip: Trip($trip.country == "UK")
		$traveller : Traveller($traveller.nationality == "Polish")
	then
		$trip.setVisaRequired( false );
end

rule "Polish citizens require visa to Australia"
	ruleflow-group "visas"
	when
		$trip: Trip($trip.country == "Australia")
		$traveller : Traveller($traveller.nationality == "Polish")
	then
		$trip.setVisaRequired( true );
end
----

What we can see is that, depending on the destination country, a `Traveller` from Poland either requires a visa or not. In this lab we will change one of these rules to demonstrate the _hot-reload_ functionality.

. Open the UI of the application and click on the blue _"+ Plan new trip"_ button.
. In the form, enter the following values and click on the blue _"Book your trip"_ button:
* Traveller:
** First Name: "Jan"
** Last Name: "Kowalski"
** Email: "jan.kowalski@example.com"
** Nationality: "Polish"
** Street: "Polna"
** City: "Krakow"
** Zip code: "32000"
** Country: "Poland"
* Trip:
** Country: "Australia"
** City: "Brisbane"
** Begin at: "2019-09-22"
** End at: "2019-09-27"
+
image:images/booking-with-visa.png[]
+
. A new entry should appear in the list of travels. The entry shows that a visa is required, indicating that the business rules have determined that a traveller from Poland travelling to Australia requires a visa.
image:images/travels-list.png[]
. Click on the _"Tasks"_ button. A task named _"Visa Application"_ should appear.
image:images/visa-application-task.png[]

 Let's now change this rule in such a way that a traveller from Poland does *not* require a visa when travelling to Australia. We will change the rule in our _DRL_ file and demonstrate the _hot-reload_ feature of Kogito.

 . Open a new SSH session to your workstation. This allows us to change one of our source files, while we keep our application running in _dev-mode_ in our other terminal.
 +
 ----
 $ export GUID=<your GUID obtained from the GuidGrabber>
 $ ssh lab-user@workstation-$GUID.rhpds.opentlc.com
 ----
 * When prompted, enter the password provided by the instructor.
 . Navigate to the project folder:
 +
 ----
 $ cd kogito-travel-agency-tutorial/01-kogito-travel-agency
 ----
. Open the `visa-rules.drl` file using VIM
+
----
vim src/main/resources/org/acme/travels/visa-rules.drl
----
+
. Navigate to the rule with the name _"Polish citizens require visa to Australia"_ and change the `then` (the rule consequence) in such a way that no visa is required:
+
[subs="quotes"]
----
rule "Polish citizens require visa to Australia"
  ruleflow-group "visas"
when
  $trip: Trip($trip.country == "Australia")
  $traveller : Traveller($traveller.nationality == "Polish")
then
  *$trip.setVisaRequired( false );*
end
----
+
. Save and exit by pressing `:wq` and `Enter`.
. In the application UI, create a new booking with the exact same data as the previous one. Observe that no visa is required.
image:images/booking-without-visa-hot-reload.png[]
. Go to the SSH terminal in which the application is running. The log will show that a change in the _DRL_ file was detected and Quarkus/Kogito reloaded the application:
+
----
2019-08-23 13:40:57,170 INFO  [io.qua.dev] (executor-thread-1) Changed source files detected, recompiling [/home/lab-user/kogito-travel-agency-tutorial/01-kogito-travel-agency/src/main/resources/org/acme/travels/visa-rules.drl]
2019-08-23 13:40:58,328 INFO  [io.quarkus] (executor-thread-1) Quarkus stopped in 0.001s
2019-08-23 13:40:58,336 INFO  [io.qua.dep.QuarkusAugmentor] (executor-thread-1) Beginning quarkus augmentation
2019-08-23 13:40:58,678 INFO  [io.qua.dep.QuarkusAugmentor] (executor-thread-1) Quarkus augmentation completed in 342ms
2019-08-23 13:40:58,725 INFO  [io.qua.swa.run.SwaggerUiServletExtension] (executor-thread-1) Swagger UI available at /swagger-ui
2019-08-23 13:40:58,779 INFO  [io.quarkus] (executor-thread-1) Quarkus 0.20.0 started in 0.451s. Listening on: http://[::]:8080
2019-08-23 13:40:58,780 INFO  [io.quarkus] (executor-thread-1) Installed features: [cdi, kogito, resteasy, resteasy-jsonb, smallrye-openapi, swagger-ui]
2019-08-23 13:40:58,780 INFO  [io.qua.dev] (executor-thread-1) Hot replace total time: 1.612s
----

We've seen the _hot-reload semantics of Kogito in action. Next we will look at how Kogito applications expose their RESTful API and how they adapt to your domain data.


== Lab 2: Domain Driven Business Applications

In previous versions of our Business Application platforms, the RESTful services always exposed generic RESTful APIs. An example of this was the commands-based API to invoke Drools Rules via KIE-Server, and the Map-based input parameters when starting a jBPM businesss process.

In Kogito, the exposed (RESTful) services are generated based on your domain data. In other words, Kogito adopts to your business domain rather than the other way around. This prevents the leaking of abstractions of the platform into your client applications and services and allows you to stay focused on the business and business domain instead of being concerned with the technology behind it.

Kogito accomplishes this by introspecting the business assets (process definitions, DRL, DMN, etc), and generating its remoting APIs based on the data-types and functionalities of your assets. This allows Kogito to expose domain specific APIs to its consumers.

A good way to demonstrate this is to inspect the Swagger documentation of our _Kogito Travel Agency_ application.

. With the _Kogito Travel Agency_ application still running, navigate to http://workstation-$GUID.rhpds.opentlc.com:8080/swagger-ui (replace $GUID with the GUID provided to you).
. Inspect the Swagger documentation. Note that the API defines RESTful resources like `Travel` and `VisaApplication` instead of `Process` and `Tasks`.
image:images/kogito-swagger.png[]

*TODO*: Have people start a Travel via the Swagger UI.

== Lab 3: Kogito Persistence




== Lab 4: Event Driven Kogito with Kafka




== Lab 5: Kogito Events and Monitoring
